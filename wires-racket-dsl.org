* basic test circuit

#+begin_src wires
x AND y -> d
x OR y -> e
x LSHIFT 2 -> f
y RSHIFT 2 -> g
NOT x -> h
NOT y -> i
123 -> x
456 -> y
#+end_src

#+RESULTS:
: d: 72
: e: 507
: f: 492
: g: 114
: h: 65412
: i: 65079
: x: 123
: y: 456


Things can be specified in any order, so the top-to-bottom state
modification from stacker won't work. We need to delay evaluation until
we have everything.

Our go-to tool for delaying evaluation: functions!

Idea is: a wire is a function you can call to get its value.

#+begin_src racket
(define (d) (wires-and (x) (y)))
;; etc for or, lshift, rshift. And then the unary operator:
(define (h) (wires-not (x)))
;; and constants:
(define (x) 123)
#+end_src

The operators would do something like:

#+begin_src racket
(define (wires-and x y)
  (bitwise-and (x) (y)))
#+end_src

Then in the above puzzle/circuit, the question of "what's the signal on
wire d?" is just ~(d)~.
* holy #*@#$* this macro does, like 80% of the DSL
:PROPERTIES:
:CREATED:  [2025-07-15T15:27:29-0500]
:END:

Holy shit, this macro is about 80% of the way to what I need:

#+begin_src racket
(define-syntax wires-operator
                 ;; literal:
  (syntax-rules (AND OR LSHIFT RSHIFT NOT ->)
    [(wires-operator lhs AND rhs -> dest)
     (define (dest) (printf "bitwise AND ~s ~s to ~s" lhs rhs dest))]
    [(wires-operator NOT lhs -> dest)
     (define (dest) (printf "bitwise NOT of ~s to ~s" lhs dest))]
    [(wires-operator input -> dest)
     (define (dest) (printf "input ~s to ~s" input dest))]
    ))

#+end_src

#+RESULTS:
: macrology.rkt> (wires-operator x AND y -> d)
: ;; no output, it just defined 'd'
: macrology.rkt> (wires-operator 456 -> y)
: macrology.rkt> (wires-operator 123 -> x)
: macrology.rkt> (x)
: input 123 to #<procedure:x>
: macrology.rkt> (y)
: input 456 to #<procedure:y>
: macrology.rkt> (d)
: bitwise AND #<procedure:x> #<procedure:y> to #<procedure:d>
: macrology.rkt> (wires-operator NOT d -> e)
: macrology.rkt> (e)
: bitwise NOT of #<procedure:d> to #<procedure:e>
: macrology.rkt>

Now get the functions to call each other!

* making =#lang wires= work
you need a collection? I thought that using raco pkg install did that?

https://docs.racket-lang.org/guide/module-basics.html#(part._link-collection)

okay, I did raco pkg install...

but then it looks like you need to do raco setup. when I do that:

#+begin_quote
aco setup: --- installing collections ---                         [9:41:11]
raco setup: --- post-installing collections ---                    [9:41:11]
raco setup: --- summary of errors ---                              [9:41:11]
raco setup: error: during making for <pkgs>/wires
raco setup:   standard-module-name-resolver: collection not found
raco setup:     for module path: wires/lang/reader
raco setup:     collection: "wires/lang"
raco setup:     in collection directories:
raco setup:      /home/dan/.local/share/racket/8.12/collects
raco setup:      /usr/share/racket/collects/
raco setup:      ... [207 additional linked and package directories]
raco setup:      sub-collection: "lang"
raco setup:     in parent directories:
raco setup:      /home/dan/Sync/code/racket/beautiful_racket/wires
raco setup:     compiling: <pkgs>/wires/wires-test.rkt
raco setup: error: during making for <pkgs>/wires
#+end_quote

When I made a lang subdirectory and put my reader code there as
reader.rkt, and also the expander code, it worked! (Building the
documentation still shows an error from the original raco stuff it put
in the scribblings directory, but I don't care about that for now.)

But, you can't run scripts from outside the "wires" directory; it fails
to find wires-syntax -- I think that's because of the way I'm requiring
the expander in the reader's output :

#+begin_src racket
    `(module wires racket/base
       (require "wires-syntax.rkt")
       ,@src-datums)
#+end_src

using

:        (require wires/lang/wires-syntax)

works!

* EOF config                                                        :ARCHIVE:
#  LocalWords:  stacker
